this에는 별도의 대상을 바인딩하는 방법도 있다.

- call 메서드
call메서드는 메서드의 호출 주체인 함수를 즉시 실행하도록 하는 명령어이다. 이떄 call메서드의 첫 번째 인자를 this로 바인딩하고, 이후의 인자들을 호출할 함수의 매개변수로 한다. 
원래 함수를 그냥 실행하면 this는 전역객체를 참조하지만 call 메서드를 이용하면 임의의 객체를 this로 지정할 수 있다. 

예) func.call({x:1},4,5,6) -> {x:1}객체를 this로 지정

- apply 메서드
apply메서드는 call메서드와 기능적으로 완전히 동일하다. apply는 call과 다르게 두 번쨰 인자를 배열로 받아 그 배열의 요소들을 매개변수로 이용한다. 

- call / apply 메서드의 활용
call과 apply를 잘 활용하면 더욱 자바스크립트를 더욱 효과적으로 사용할 수 있다. 
객체에는 배열 메서드를 직접 적용할 수 없지만, 배열과 구조가 비슷한 객체의 경우 call또는 apply 메서드를 이용해 배열 메서드를 차용할 수 있다. 
또 배열처럼 인덱스와 lenght 프로퍼티를 지니는 문자열에 대해서도 마찬가지 입니다. 
단, 문자열의 경우 length 프로퍼티가 읽기 전용이기 때문에 원본을 바꾸는 메서드는 에러를 던진다. 또 concat처럼 대상이 반드시 배열이어야 하는 겨우는 에러는 나지 않아도 제대로 된 결과를 얻을 수 없다. 

#생성자 내부에서 다른 생성자를 호출
생성자 내부에 다른 생성자와 공통된 내용이 있을경우 call이나 apply를 이용하면 더욱 간단하게 처리할 수 있다.
(함수를 클래스 형식으로 사용하면서 사용가능)

#여러 인수를 묶어 하나의 배열로 전달하고 싶을 때 - apply 활용
여러 개의 인수를 받는 메서드에게 하나의 배열로 인수들을 전달하고 싶을 때 apply메서드를 사용하면 좋다.
예를 들어, 배열에서 최대/최솟값을 구해야 할 경우 apply를 사용하지 않는다면 직접 구현해야만 한다.
하지만 Math.max/Math.min과 apply를 이용한다면 휠씬 간단하게 값을 구할 수 있다.
(참고로 ES6에서는 펼치기 연산자를 이용하면 apply를 적용하는 것보다 간단하게 구할 수 있다.)
하지만 단점도 존재한다. apply를 사용하면 this의 값을 예측하기 어려워 코드 해석을 방해한다. 

- bind 메서드
bind 메서드는 call과 비슷하지만 즉시 호출하지 않고 넘겨 받은 this와 인수들을 이용해 새로운 함수를 반화하는 메서드이다.
bind 메서드는 함수에 this를 미리 적용하는 것과 부분 적용 함수를 구현하는 두 가지 목적을 모두 가진다.
또, bind 메서드를 이용할 때 일부의 인자들만 넘겨 사용할 수 있다. 

#name 프로퍼티
bind 메서드를 적용해서 만든 함수는 특이한 성질이 있다. 바로 name 프로퍼티를 이용하면 'bound'가 붙는 것이다.
이 뜻은 일반적인 함수에 bind메서드를 적용한 새로운 함수라는 의미가 된다. 

#상위 컨텍스트의 this를 내부함수나 콜백 함수에 전달하기
3-1-3에서 변수를 이용해서 this를 우회했는데 call, apply, bind를 이용한다면 더욱 쉽고 깔끔하게 사용할 수 있다.
(내부 함수 뒤에.bind(this)를 이용하면 가능하다.)
또, 함수를 인자로 받는 함수나 메서드 중 기본적으로 콜백 함수 내에서의 this에 관여하는 함수 또는 메서드에 대해서도
bind 메서드를 이용하면 this값을 사용자의 입맛에 맞게 바꿀 수 있다. 
(콜백함수에서의 this는 전역객체를 지정할 수 있어 bind를 이용한다)

#화살표 함수의 예외사항
앞서 말했듯 화살표 함수는 this를 바인딩하는 과정이 제외된다. 즉, 이 함수 내부에는 this가 아예 없거나 접근을 원한다면 상위스코프의 this에 접근한다.

- 별도의 인자로 this를 받는 경우(콜백 함수 내에서의 this)
콜백 함수를 인자로 받는 메서드 중 일부는 추가로 this로 지정할 객체를 인자로 지정할 수 있는 경우가 있다. 
이러한 메서드의 thisArg 값을 지정하면 콜백 함수 내부에서 this값을 원하는 대로 변경할 수 있다. 
