앞선 this의 규칙 이외에도 별도의 대상을 바인딩하는 방법도 있다. 

1) call 메서드 
= 메서드의 호출주체인 함수를 즉시 실행하도록 하는 명령
call 메서드의 첫 번째 인자를 this으로 바인딩하고, ㅇ후의 인자들을 호출할 함수의 매개변수를 매개변수로 한다. 이를 그냥 실행하면 this는 전역객체를 참조핮만 call 메서드를 이용하면 임의의 객체를 this로 저장할 수 있다.
객체의 메서드를 그냥 호출하면 this는 객체를 참조하지만 call메서드를 이용하면 임의의 객체를 this로 지정할 수 있다.

2) apply 메서드
= call 메서드와 기능적으로 완전히 동일한 메서드로
call 메서드는 첫 번째 인자를 제외한 나머지 모든 인자들을 호출할 함수의 매개변수로 지정하지만 apply에서는 두 번째 인자를 배열로 받아 그 배열의 요소들을 호출할 함수의 매개변수로 지정한다는 차이점이 있다.

+ 여러 인수를 묶어 하나의 배열로 전달하고 싶을 때
= 여러개의 인수를 받는 메서드에게 하나의 배열로 인수들을 전달하고 싶을 때
, 배열에서 최대/최소값을 구해야할 경우

*call/apply 메서드의 단점 = this를 예측하기 어렵게 만들어 코드 해석을 방해한다는 단점이 있다.

3) slice 메서드
= 원래 시작 인덱스값과 마지막 인덱스값을 받아 시작값부터 마지막값의 앞부분까지의 배열요소를 추출하는 메서드
, 매개변수를 아무것도 넘기지 않을 경우에는 그냥 원본배열의 얕은 복사본을 반환
, 오직 배열 형태로 복사하기 위해서 차용 됐을 뿐 어떤 의도에서 차용됐는지 정확히 알 수 없다. 
// call메서드는 원본인 유사배열 객체의 얕은 복사를 수행한 것 인데, slice메서드가 배열 메서드이기 때문에 복사본은 배열로 반환하게 된 것

4) argument 객체도 유사배열 객체로 위와 같은 방법으로 배열을 전환해서 사용할 수 있다.

5) bind 메서드
= call과 비슷하지만 즉시 호출하지는 않고 넘겨받은 this및 인수들을 바탕으로 새로운 함수를
반환하기만하는 메서드 (인수를 넘기면 인수들이 기존메서드에서 호출할 떄 전달했던 인수들의 뒤로 등록된다.)


*각 메서드의 활용

@ 유사배열객체에 배열 메서드를 사용
= 객체에는 배열 메서드를 직접 사용할 수 없지만 키가 0 또는 양의 정수인 프로퍼티가 존재하고 길이 프로퍼티의 값이 0또는 양의 정수인 객체, 즉 배열의 구조와 유사한 객체의 경우 배열메서드를 이용할 수 있다.

+ 단, 문자열의 경우 length 프로퍼티가 읽기전용이기 떄문에 원본 문자열에 변경을 가하는 메서드는 에러는 나지 않지만 제대로 된 결과를 얻을 수 없다.

- 생성자 내부에서 다른 생성자를 호출
=  생성자 내부에 다른 생성자와 공통된 내용이 있을 경우 call, apply를 이용해 다른 생성자를 호출하면 간단하게 반복을 줄일 수 있다.

name 프로퍼티 
= 함수명이 xxx인 원본함수에 바인드 메서드를 적용한 새로운 함수의 의미가 되므로 기존의 call이나 apply보다 코드를 추적하기에 더 수월하다.

@ 상위 컨텍스트의this를 내부함수나 콜백함수에 전달하기
메서드의 내부함수에서 메서드의 this를 그대로 바라보게하기 위한 방법으로 self 등의 변수를 사용하는 우회법을 사용하지 않고도 call,apply,bind 함수를 이용하면 편리하다.

@ 화살표 함수의 예외사항
-> 새롭게 도입된 화살표 함수는 실행 컨텍스트 생성시 this 를 바인딩하는 과정이 제외. 이 함수내부에는 this가 아예 없으며 접근하고자 하면 스코프 체인상 가장 가까운 thsi에 접근하게 된다.

@ 별도의 인자로 this를 받는 경우 (콜백함수 내에서의 thiS)
-> 콜백함수를 인자로 받는 메서드중 일부는 추가로 this로 지정할 객체를 인자로 지정할 수 있는 경우가 있다.
이런 메서드의 값을 지정하면 콜백함수 내에서 this값을 원하는 대로 변경이 가능하다.
이런 형태는 여러 내부요소에 대해 같은 동작을 반복수행해야하는 배열메서드에 많이 포진되어 있다.

