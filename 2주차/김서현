[36] Chapter 2. 실행 컨텍스트
실행 컨텍스트: 실행할 코드에 제공할 환경 정보들을 모아놓은 객체 
[36]2-1 실행 컨텍스트란?
ㄴ 스택 : 출입구가 하나뿐인 깊은 우물 데이터같은 구조(ex 스택오버플로우)//abcd >> dcba
ㄴ 큐 : 양쪽이 모두 열려있는 파이프 , 보통 한쪽은 입력만, 다른 한쪽은 출력만을 담당하는 구조// abcd >> abcd

1 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 컨텍스트 구성
2 1을 콜 스택에 쌓아올렸다가, 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 전체 코드의 환경과 순서를 보장.
  ㄴ '동일한 환경', 하나의 실행 컨텍스트를 구성할 수 있는 방법으로 전역공간, eval()함수, 함수등이 있음,
  흔히 실행 컨텍스트 구성하는 방법: 함수 실행 

  [38-39]예제 2-1, 실행 컨텍스트와 콜 스택

  var a = 1;
  function outer(){
    function inner(){
        console.log(a);
        var a =3;
    }
    inner();
    console.log(a);

    }
    outer();
    console.log(a);

    스택 구조 고려시, 한 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간 =현재 실행할 코드에 관여하게 되는 시점
    : 기존 컨텍스트가 새로 쌓인 컨텍스트보다 아래에 위치하기 때문. 
    >> js 엔진은 해당 컨텍스트에 관련된 코드들을 실행하는 데 필요한 환경 정보들을 수집해서 실행 컨텍스트 객체에 저장함. 
    이 객체는 js엔진이 활용할 목적으로 생성할 뿐 개발자가 코드를 통해 확인할 수는 없음. 
    담기는 정보들
    1. VariableEnvironment: 현재 컨텍스트 내의 식별자들에 대한 정보 + 외부 환경 정보, 
    선언 시점의 LexicalEnvironment의 스냅샷으로, 변경사항은 반영되지 않음.
    2. LexicalEnvironment: 처음에는 VariableEnvironment와 같으나 변경사항이 실시간으로 반영됨.
    3. ThisBinding: this 식별자가 바라봐야할 대상 객체.

    [40] 2-2 : VariableEnvironment
    VariableEnvironment에 담기는 내용은 LexicalEnvironment같으나 최초 실행시 스냅샷을 유지한다는 점이 다름!
    실행 컨텍스트 생성시, VariableEnvironment 정보를 담은 후, 그대로 복사해 LexicalEnvironment를 만들고, 
    LexicalEnvironment를 주로 활용하게 됨.

    VariableEnvironment와 LexicalEnvironment의 내부는 environmentRecord , outerEnvironment로 구성되어있음
    초기화 과정: 사실상 완전히 동일
    이후 코드 진행에 따라 서로 달라지게 될 것임. //2-3 참고 필요

    [41] 2-3 LexicalEnvironment
    (번역) '어휘적 환경', '정치적 환경' >> 둘다 그닥 적절한 해석은 아님
    "사전적인" 이 더 어울리는 표현 : 백과사전 느낌, 특성을 설명함.

    [42] 2-3-1 environmentRecord 와 호이스팅
    environmentRecord에는 매개변수의 이름, 함수 선언, 변수명 등이 담김.
    *호이스팅: 변수 정보를 수집하는 과정

    [43] 예제 2-2 매개변수와 변수에 대한 호이스팅(1) - 호이스팅이 되지 않았을 떄: 인자들과 함께 함수를 호출한 경우
    function a (x){
    console.log(x);
    var x;
    console.log(x);
    var x =2;
    console.log(x);
    }
    a(1)
 
 //예제 2-2는 arguments에 전달된 인자를 담는 것을 제외하면 , 2-3과 코드내부에서 변수를 선언한 점이 같다.

    [44] 예제 2-3 매개변수와 변수에 대한 호이스팅(2) - 매개변수를 변수 선언/할당과 같다고 간주, 변환
    function a (){
        var x =1;
        console.log(x);
        var x;
        console.log(x);
        var x =2;
        console.log(x);
    }
    a();
//environmentRecord는 현재 실행된 컨텍스트의 대상 코드 내에 어떤 식별자들이 있는지에만 신경쓴다. 
각 식별자에 어떤 값이 할당될 것인지는 관심이 없다. 
>> 매개변수/변수 호이스팅할때 매개변수/변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다. 

  [44] 예제 2-4 매개변수와 변수에 대한 호이스팅(3) - 호이스팅 마친 상태
  
  function a (){
   var x;// *1, 변수 선언, 메모리에서 저장할 공간 미리 확보, 확보한 공간의 주솟값을 변수 x에 연결
   var x; // *2, 다시 변수 x 선언, 이미 선언된 변수 x가 있으므로 무시
   var x; // *3,  다시 변수 x 선언, 이미 선언된 변수 x가 있으므로 무시

   x = 1; x에 1할당, 숫자 1을 별도 메모리에 담고, x와 연결된 메모리 공간에 숫자 1을 가리키는 주솟값 입력
   console.log(x); 1 출력
   console.log(x); 1 출력
   x=2; 숫자 2 별도 메모리에 담고 그 주솟값을 x 와 연결된 메모리 공간으로 감. 1 주솟값을 2 주솟값으로 대치.
   console.log(x); *3에서 2 출력 , 함수 내부 모든 코드 실행됨>> 실행 컨텍스트가 콜 스택에서 제거. 
  }
  a(1);

 ****함수 선언 추가 예제
  [45] 예제 2-5 함수 선언의 호이스팅 (1) - 원본 코드

  function a () {
    console.log(b); 
    var b = 'bbb'; // *1 : 수집대상, 변수 선언
    console.log(b);
    function b(){} // *2 : 수집대상, 함수 선언
  
   console.log(b);
  }
  a();

  [46] 예제 2-6: 함수 선언의 호이스팅(2) - 호이스팅 완료
  
  function a(){
    var b; // 수집대상 *1, 변수는 선언부만 끌어올림
    function b(){} // 수집대상 *2, 함수 선언은 전체를 끌어올림
    
    console.log(b);// -i
    b='bbb'; 
    console.log(b);// -ii
    console.log(b);//-iii
  }
  a();
  >> 호이스팅 끝난 뒤 함수 선언문은 함수명으로 선언한 변수에 함수를 할당한 것처럼 여길 수 있음.

  [47] 예제 2-7 함수 선언의 호이스팅(3) - 함수 선언문을 함수 표현식으로 바꾼 코드

  function a (){
    var b;//변수 b 선언, 메모리에선 저장할 공간 미리 확보, 확보한 공간의 주솟값을 변수 b에 연결
    var b = function b(){} // ! 바뀐 부분
    // 다시 변수 b선언후 함수 b를 선언된 변수 b에 할당하려 시도. 이미 선언된 변수 b가 있으므로 선언된 과정 무시. 
    함수는 별도 메모리에 담김, 그 함수가 저장된 주솟값을 b와 연결된 공간에 저장함. 이제 변수 b는 함수를 가리킴

    console.log(b); 변수 b에 할당된 함수 b출력
    b='bbb'; 변수 b에 'bbb'할당 시도. b와 연결된 메모리 공간엔 문자열 'bbb'가 담긴 주솟값으로 덮어짐
    >> 변수 b는 문자열 'bbb'를 가리킴
    console.log(b); // 'bbb' 출력
    console.log(b); // 'bbb' 출력,, 함수 내부 모든 코드가 실행됐으므로 실행 컨텍스트가 콜 스택에서 제거됨.

  }
  a();

  [48] 함수 선언문과 함수 표현식
  함수 선언문 : function 정의부만 존재, 별도의 할당 명령 없음       반드시 함수명이 정의돼 있어야함
  함수 표현식 : 정의한 function을 별도의 변수에 할당하는 것을 말함.        함수명 없어도 됨.
  ㄴ 기명 함수 표현식 : 함수명 정의 함수 표현식
     익명 함수 표현식 : 함수명 정의안한 함수 표현식

ex : 함수 선언문, 함수명 a = 변수명
function a (){/**/}
a();

ex : 익명 함수 표현식, 변수명 b = 함수명
var b = function(){/**/}
b();

ex : 기명 함수 표현식, 변수명 c, 함수명 d
var c = function d(){/**/}
c();//실행 가능
d();//에러!

****** 함수 선언문과 함수 표현식 실질적 차이   

[49] 예제 2-10 함수 선언문과 함수 표현식(2) - 호이스팅을 마친 상태
var sum = function sum(a,b){//함수 선언문 전체 호이스팅
    return a+b;
};
var multiply; // 변수는 선언부만 끌어올림
console.log(sum(1,2));
console.log(multiply(3,4));

multiply = function (a,b){ //변수 할당부 원래 자리에 남겨둠
    return a*b;
};

함수 선언문은 전체를 호이스팅
함수 표현식은 변수 선언부만 호이스팅. >> 함수를 다른 변수에 값으로써 '할당'한 것이 곧 함수 표현식

********* 함수 선언문의 위험성 >> 협업시 함수 표현식이 보다 안전하다. 
: 안좋은 상황이나, 전역공간에 동명의 함수가 여럿 존재하는 상황 대비.
[[override]] 
전역 컨텍스트가 활성화될 때 전역공간에 선언된 함수들이 모두 가장 위로 끌어올려짐. 
동일한 변수명에 서로 다른 값을 할당할 경우 나중에 할당한 값이 먼저 할당한 값을 덮어씌움. 
>> 코드를 실행하는 중에 실제로 호출되는 함수는 오직 마지막에 할당한 함수임. 

암묵적 형변환에 의해 에러 찾기가 매우 어려울 수 있음. 

[51] 예제 2-11 함수 선언문의 위험성
....
console.log(sum(3,4));
...
function sum(x,y){
    return x+y;
}
...
var a = sum(1,2);
...
function sum(x,y){
    return x+'+' + y +'='+(x+y);
}
...
var c = sum(1,2);
console.log(c);
...
함수 표현식을 사용할 경우, 함수 표현식 선언 이후 범위로 새롭게 정의된 뜻이 적용되므로 에러검출이 보다 빠름. 

[52] 예제 2-12 상대적으로 함수 표현식이 안전함
...
console.log(sum(3,4));
...
var sum = function (x,y) {
    return x + y;
};
...
var a = sum(1,2);
...
var sum = function(x,y){
    return x + '+' + y + '=' + (x+y);
};
...
var c = sum(1,2);
console.log(c);
...