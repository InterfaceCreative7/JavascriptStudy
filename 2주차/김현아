[chapter 2]

@ 실행 컨텍스트 (execution context) : '실행할 코드에 제공할 환경 정보들을 모아놓은 객체'
@ 호이스팅 (hoisting) : 어떤 실행 컨텍스트가 활성화되는 시점에 선언된 변수를 위로 끌어올림

<01>
* 실행 컨텍스트 -> 전체 코드의 환경과 순서를 보장
    - 스택 (stack) : 출입구가 하나인 깊은 우물같은 데이터 구조 (-> 스택이 넘치면 에러가 난다.)
    - 큐 (queue) : 양쪽이 모두 열려있는 파이프 

    ** 하나의 실행 컨텍스트를 구성할 수 있는 방법
        - 전역공간 (-> 자동으로 생성)
        - eval() 함수 (-> 악마로 취급)
        - 함수 (-> 흔히 실행 컨텍스트를 구성하는 방법)
            + 콜 스택에 실행 컨텍스트가 어떤 순서로 쌓이고, 어떤 순서로 실행에 관여할까?
                (1) 코드 실행 :  전역 콘텍스트 (-> 자바스크립트 파일이 열리는 순간 전역 컨텍스트 활성화)
                (2) 코드 순차 진행 : outer 함수 호출 (-> 전역 컨텍스트와 관련된 코드 실행 일시중단)
                (3) outer 함수 내부 코드 순차 진행 : inner 함수 (-> outer 컨텍스트와 관련된 코드 실행 일시중단)
                (4) inner 함수 내부 코드 순차 진행 : inner 함수 실행 종료 (-> 콜스택에서 제거)
                (5) 일시중단된 outer 함수 나머지 실행 : outer 함수 실행 종료 (-> 콜스택에서 제거)
                (6) 일시중단된 전역 컨텍스트 나머지 실행 : 전역 컨텍스트 콜스택에서 제거 (-> 아무것도 남지 않은 상태로 종료)
             => 실행 컨텍스트가 콜 스택의 맨 위에 쌓이는 순간 = 현재 실행할 코드에 관여하게 되는 시점   

<02>
* VariableEvironment : 담기는 내용은 LexicalEvironment와 같음 but, 최초 실행 시의 스냅샷을 유지
    -> 실행 컨텍스트 생성시
        (1) VariableEvironment에 정보 담기
        (2) 그대로 복사 후 LexicalEvironment 만들기
        (3) LexicalEvironment를 주로 활용
    -> VariableEvironment와 LexicalEvironment의 내부는 'evironmentRecord'와 'outerEvironmentReference'로 구성

<03> 
* LexicalEvironment : '사전적 환경'
* evironmentRecord와 호이스팅
    - evironmentRecord : 현재 컨텍스트와 관련된 코드의 식별자 정보 저장 (순서대로 수집)
        - 매개변수의 이름
        - 함수 선언
        - 변수명 등이 담겨 있음

    - 호이스팅 : 변수 정보를 수집하는 과정을 더욱 이해하기 쉬운 방법으로 대체한 가상의 개념
        - 호이스팅 되지 않았을 때 (//예상 결과)
        # function a (x){
        #   consol.log(x);  // 1 출력
        #   var x;
        #   consol.log(x);  // undefined 출력
        #   var x = 2;
        #   consol.log(x);  // 2 출력
        # }
        # a(1);
        - 매개변수 선언시 
        # function a (){
        #   var x = 1;
        #   consol.log(x);  // 1 출력
        #   var x;ㅋ
        #   consol.log(x);  // undefined 출력
        #   var x = 2;
        #   consol.log(x);  // 2 출력
        # }
        # a();
        - 호이스팅 처리했을 때
        # function a (){
        #   var x;
        #   var x;
        #   var x;
        #
        #   x = 1;
        #   consol.log(x);  // 1 출력  
        #   consol.log(x);  // 1 출력
        #   x = 2;
        #   consol.log(x);  // 2 출력
        # }
        # a(1);

        + 변수 : 선언부와 할당부를 나누어 선언부만 끌어올림
          함수 선언 : 함수 전체 끌어올림

    - 함수 선언문과 함수 표현식 : 함수를 새롭게 정의할 때 쓰이는 방식
        - 함수 선언문 : function 정의부만 존재, 별도의 할당 명령 X, 반드시 함수명이 정의돼 있어야 함
        - 함수 표현식 : 정의한 function을 별도의 변수에 할당, 반드시 함수명이 정의돼 있지 않아도 됨 (일반적으로 익명 함수 표현식)
            - 익명 함수 표현식 : 함수명을 정의하지 않은 함수 표현식
            - 기명 함수 표현식 : 함수명을 정의한 함수 표현식
            # function a(){}
            # a();          // 함수 선언문 (함수명 a가 곧 변수명)

            # var b = function (){}
            # b();          // 익명 함수 표현식 (변수명 b가 곧 함수명)

            # var c = function d (){}
            # c();          
            # d();          // 기명 함수 표현식 (변수명은 c, 함수명은 d)
            + 실질적 차이 
                - 함수 선언문 : '전체'를 호이스팅
                - 함수 표현식 : '변수 선언부'만 호이스팅