- 콜백 함수 내부의 this에 다른 값 바인딩하기
복습해보면 객체의 메서드를 콜백 함수로 전달하면 해당 객체를 this로 바라볼 수 없다. 
별도의 인자로 this를 받는 함수의 경우 원하는 값을 넘겨주면 되지만 그렇지 않은 경우에는 this의 제어권도 넘겨주게 되므로 사용자가 임의로 값을 바꿀 수 없다. 
그래서 this를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 this 대신 그 변수를 사용하게 한다. 

bind를 사용해서 메서드를 이용하는 방법을 사용하먄 다른 값 을 this로 사용 가능하다. 

- 콜백 지옥과 비동기 제어
콜백 지옥은 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들려쓰기 수준이 감당하기 힘들 정도로 갚어지는 현상이다. 
주로 이벤트 처리하는데에서 나오는데 가독성이 떨어지고 코드를 수정하기 어렵다.
비동기는 동기의 반대말이다. 

동기적인 코드: 현재 실행 중인 코드가 완료된 후에야 다음 코드를 실행하는 방식
비동기적인 코드: 현재 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어가는 방식

동기적인 코드는 cpu의 계산으로 즉시 처리가 가능한 코드이며 께산식이 복잡해 cpu가 계산하는 데 시간이 많이 필요한 경우도 동기적인 코드다.
반면, 사용자의 직접적인 개입이 있을때 실행하거나 대기하는 함수인 경우 비동기적이다. 
웹브라우저 자체가 아닌 별도의 대상에 무언가를 요청하고 그에 대한 응답이 왔을 때 비로소 어떤 함수를 실행하도록 대가하고 병도의 요청, 실행 대기 보류등 모두 비동기와 관련되어 있다. 

웹의 복잡도가 높아지면서 비동기적인 코드의 비중이 예정보다 훨씬 높아진 상황이다. 
콜백 지옥을 빠져나오기 위해서는 요즘 나온 ES6에서의 promise, Generator, ES2019에서의 async/await을 이옹하면 된다. 

또 비동기 작업은 클로저를 이용해서 반복적인 내용을 함수로 짧게 표현할 수 있다.
ES6의 Generator를 이용하기 위해서는 함수 앞에 *을 붙이면 된다. 
Generator함수를 실행하면 Iterator가 반환된다. Iterator에서는 next라는 메서드를 가지고 있다.
next를 호출하면 함수 내부에서 먼저 등장하는 yield에서 함수의 실행을 멈출수 있다. 
비동기 작업이 완료되는 시점마다 next 메서드를 호출해준다면 Generator 함수 내부의 소스가 위에서부터 아래로 순차적으로 진행한다. 
