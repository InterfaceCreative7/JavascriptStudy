<04> 
* 콜백 함수 내부의 this에 다른 값 바인딩하기
    - 별도의 인자로 this를 받는 함수의 경우 : 원하는 값을 넘겨주면 된다. 그렇지 않은 경우 this의 제어권도 넘겨주게 되어 사용자가 임의로 값을 바꿀 수 없다. 
                                            => this를 다른 변수에 담아 콜백 함수로 활용할 함수에서는 this 대신 그 변수를 사용하게 하고 이를 클로저로 만듦 (전통적인 방식)
    - 콜백 함수 내부에서 this를 사용하지 않은 경우 : 훨씬 간결하고 직관적 but, 작성한 함수를 this를 이용해 다양한 상황에 재활용할 수 없음
    - bind 메서드 이용 : call과 비슷하지만 즉시 호출하지는 않고 넘겨 받은 this 및 인수들을 바탕으로 새로운 함수를 반환하기만 하는 메서드

<05>
* 콜백 지옥과 비동기 제어권
    - 콜백 지옥 : 콜백 함수를 익명 함수로 전달하는 과정이 반복되어 코드의 들여쓰기 수준이 감당하기 힘들 정도로 깊어지는 현상
        => 콜백 지옥 해결 : 기명함수로 변환 (-> 코드의 가독성을 높임)
    - 비동기 제어권 : 현자 실행 중인 코드의 완료 여부와 무관하게 즉시 다음 코드로 넘어감.
                    별도의 요청, 실행 대기, 보류 등과 관련된 코드는 '비동기적인 코드'
        => 비동기적인 작업을 동기적으로 보이게 하는 방법
            (1)  Promise 
                : new 연산자와 함께 호출한 Promise의 인자로 넘겨주는 콜백 함수는 호출할 때 바로 실행
                  but, 그 내부에 resolve 또는 reject 함수를 호출하는 구문이 있을 경우 둘 중 하나가 실행되기 전까지는 다음 또는 오류 구문으로 넘어가지 않는다.
            (2)  Generator 
                : '*'이 붙은 함수
                  Generator 함수를 실행하면 Iterator가 반환됨 (Iterator는 next라는 메서드를 가지고 있다.)
            (3) Promise + Async/await
                : 가독성이 뛰어나면서 작성법도 간단함.
                  비동기 작업을 수행하고자 하는 함수 앞 -> async 표기
                  함수 내부에서 실질적인 비동기 작업이 필요한 위치마다 -> await 표기
                  뒤의 내용을 Promise로 자동 전환, 해당 내용이 resolve된 이후에야 다음으로 진행
                  (Promise의 then과 흡사한 효과를 얻을 수 있음.)
