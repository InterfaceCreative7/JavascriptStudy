자바스크립트로 개발을 하다보면 가장 혼란의 여지가 많은 부분이 this부분이다. 
this는 상황에 따라 바라보는 대상이 달라지는데, 그 상황들을 알아보자

- 상황에 따라 달라지는 this
자바스크립트에서 this는 기본적으로 실행컨텍스트가 생성될 때 함께 결정된다. 즉, this는 함수가 호출힐 때 결정된다. 
함수를 어떤 방식으로 호출하냐에 따라 달라진다. 

#전역 공간에서의 this
전역 공간에서 this는 전역 객체를 가리킨다. 전역 객체는 자바스크립트 런타임 환경에 따라 다른 이름과 정보를 가진다.
브라우저 환경에서 전역객체는 window고 Node.js 환경에서는 global이다. 

##전역 공간의 특이한 성질
전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다. 객체이면서 프로퍼티이기도 하다.
만약 전역공간에서 a에 1을 할당했을 때 window.a와 this.a는 모두 1이 출력된다. 전역공간에서의 this는 전역객체를 의미하므로 두값이 같은 값을 출력한다. 
실행컨텍스트는 변수를 수집해 L.E에 저장하는데, 어떤 변수를 호출하면 L.E를 조회해서 일치하는 프로퍼티가 있을 경우 그 값을 반환한다. 

전역변수를 선언하면 자바스크립트 엔진은 이를 전역개체의 프로퍼티로 할당한다. 
즉 var로 변수를 선언하는것과 window의 프로퍼치에 직접 할당하는것이 결과적으로 var로 선언한 것과 똑같이 동작할 것이다. 
할당과는 다르게 삭제 명령은 다르다. 처음부터 전역객체의 프로퍼치로 할당한 경우에는 삭제가 되는 반면 전역변수로 선언한 경우에는 삭제가 되지 않는다.
이는 사용자가 의도치 않게 삭제하는 것을 방지하는 차원에서 마련한 나름의 방어 전약이다. 
즉, 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼치의 configurable 속성을 false로 정의하는 것이다.

이처럼 var로 선언한 변수와 전역객체의 프로퍼티는 호이스팅 여부 및 configurable여부에서 차이를 보인다. 

#메서드로서 호출할 때 그 메서드 내부에서의 this

## 함수 vs 메서드
함수를 실행하는 방법은 여러 가지가 있는데, 가장 일반적인 방법이 두 가지있다.
1. 함수로서 호출하는 경우
2. 메서드로서 호출하는 경우

함수와 메서드는 미리 정의한 동작을 수행하는 코드 뭉치로, 이 둘을 구분하는 유일한 차이는 독립성에 있다.
함수는 그 자체로 독립적인 기능을 수행하지만, 메서드는 자신을 호출한 대상 객체에 관한 동작을 수행한다. 
여기서 자바스크립트는 상황별로 this 키워드에 다른 값을 부여하여 이를 구현했다. 
많은 사람들이 메서드를 '객체의 프로퍼티에 할당된 함수'로 이해하지만 이는 반은 맞고 반은 틀리다.
어떤 함수를 객체의 프로퍼티에 할당한다고 해서 그자체가 무조건 메서드가 되는 것이 아니라 객체의 메서드로 호출할 경우만 메서드로 동작한다.

일반 함수에서 호출한것은 this를 window이지만 메서드를 이용한 것은 객체를 가린킨다.
그렇다면 함수로서 호출과 메서드로서 호출은 어떻게 구분할까? 함수 앞에 점이 있는지 여부만으로 간단하게 구분할 수 있다.
다시 말해 어떤 함수를 호출할 때 그 함수 이름 앞에 객체가 명시돼 있는 경우에는 메서드로 호출 그렇지 않으면 함수로 호출한다. 

##메서드 내부에서의 this
this에는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로 호출하는 경우 호출 주체는 바로 함수명 앞의 객체다.
점표기법으로 설명하자면 마지막 점 앞에 명시된 객체가 this가 되는 것이다. 

메서드 내부에서 정의하고 실행하는 함수에서의 this는 우리에게 혼란을 야기한다. 이번에도 함수로 호출했는데 메서드로 호출했는지로 우리는 충분히 해결할 수 있다.
함수로 호출한 경우 window 메서드로 호출한 경우는 호출한 주체라고 생각하면 된다. (메서드안에 함수도 window가능하다.)

#함수로서 호출할 때 그 함수 내부에서의 this
어떤 함수를 함수로 호출할 경우 this는 지정되지 않는다. 함수로서 호출하는 것은 호출 주체를 명시하지 않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출 주체의 정보를 알수 없다.
따라서 함수에서의 this는 전역 객체를 가리킨다. 

#메서드의 내부 함수에서 this를 우회하는 방법
우리는 this가 호출 주체가 없을 때는 자동으로 전역객체를 바인딩하지 않고 호출 당시 주변 환경의 this를 그대로 상속받아 사용하고 싶다. 
아쉽게도 ES5에는 자체적으로 내부함수에 this를 상속할 방법이 없지만 이를 우회할 방법이 없지는 않다.

그 중 대표적인 방법으로는 변수를 활용하는 것이 있다. 의미만 통하면 상관없이 변수를 아무거나 사용하여 그 변수에 this를 입력하면 된다. 

#this를 바인딩하지 않는 함수
ES6에서는 문제를 보완하고자 화살표 함수를 새로 도입하였다. 화살표 함수를 사용하면 this 바인딩 과정 자체가 빠지게 되어, 상위 스코프의 this를 그대로 활용할 수 있다.
그 밖에도 call, apply등 메서드를 활용해 함수를 호출할 때 명시적으로 this를 지정하는 방법이 있다. 

#콜백 함수 호출 시 그 함수 내부에서의 this
setTimeout함수와 forEach 메서드는 그 내부에서 콜백 함수를 호출할 때 대상이 this를 지정하지 않고 전역객체를 참조한다. 
한편 addEventListener 메서드는 콜백 함수를 호출할 때 자신의 this를 상속하도록 정의돼 있다. 즉, 메서드명의 점 앞부분이 곧 this가 되는 것이다. 
이처럼 콜백 함수에서의 this는 무조건 이것이라고 정의할 수 없다. 콜백 함수의 제어권을 가지는 함수가 콜백 함수에서의 this를 무엇으로 할지 결정하며, 특별히 정의하지 않는다면 젼역객체를 바라본다.

#생성자 함수 내부에서의 this
생성자 함수는 어떤 공통된 성질을 지니는 객체들을 생성하는 데 사용하는 함수다. 프로그래밍적으로 '생성자'는 구체적인 인스턴스를 만들기 위한 일종의 틀이다.
이 틀에는 해당 클래스의 공통 속성들이 미리 준비돼 있고, 여기에 구체적인 인스턴스의 개성을 더해 개별 인스턴스를 만들 수 있다. 
new 명령어와 함께 함수를 호출하면 해당 함수가 생성자로 동작한다. 어떤 함수가 생성자 함수로 호출된 경우 내부에서의 this는 곧 새로 만든 구체적인 인스턴스 자신이 된다.
생성자 함수를 호출 하면 프로퍼티가 있는 객체를 생성하고 공통 속성 및 개성을 해당 객체에 부여한다. 이렇게 하면 구체적인 인스턴스가 만들어 진다. 

