3주차

this: 클래스로 생성한 인스턴트 객체를 의미
함수와 객체의 구분이 느슨한 자바스크립트에서 this는 구분할 수 있는 기능이 있다.

*상황에 따라 달라지는 this 
this는 실행컨텍스트가 생성될 때 함께 결정된다. 실행 컨텍스트는 함수가 호출될 때 실행되므로 ==> this는 함수를 호출할 때 결정됨

전역공간에서 this는 전역객체를 가르킨다.(전역컨텍스트를 생성하는 주체가 바로 전역객체) 런타임 환경에 따라 다른 이름과 정보를 가지고 있다.
(전역객체=윈도우, Node.js환경 = 글로벌)

*전역공간에서 발생하는 특이한 성질: 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티(문자열 안에 있는 문자의 양을 정수로 나타낸 값)로도 할당가능.

전역공간에서의 this는 전역객체를 의미하므로 두값(윈도우.a, this.a)이 모두 출력되는 것은 당연하지만 그 값이 1인 이유: 자바스크립트의 모든 변수는 특정 프로퍼티로 동작하기 때문에.

사용자가 변수를 연산자를 이용해 선언하더라고 자바스크립의 엔진에서는 프로퍼티로 인식함

실행 컨텍스트는 변수를 수집해서 L.E의 프로퍼티에 저장 -> 어떤 변수를 호출하면 L.E를 조회해서 일치하는 프로퍼티를 찾으면 그 값으로 변환 
// 전역변수를 선언하면 자바스크립트 엔진은 이를 전역객체의 프로퍼티로 할당한다 => window.a, this.a가 1로 출력되는 이유가 설명가능
(그렇다면 왜 a를 직접 호출해도 1이 나올까?: 변수a에 접근하고자 하면 스코프체인에서 a를 검색하다가 
가장 마지막에 도달하는 전역스코프, 전역객체에서 해당 프로퍼티를 발견해서 -> window. 이 생략된 것이라 여겨도 무방하다.)

전역공간에서는 var로 변수를 선언하는 대신 window의 프로퍼티에 직접할당하는 것도 결과적으로 똑같이 동작한다.
예외) 전역변수 선언과 전역객체의 프로퍼티 할당 사이에 전혀 다른 경우도 존재 *삭제명령*

*delete: 전역변수를 선언하면 자바스크립트 엔진이 이를 자동으로 전역객체의 프로퍼티로 할당하면서 추가적으로 해당 프로퍼티의 변경 및 삭제 가능성을 false로 정의하는 것

함수를 실행하는 방법
1)-함수로 호출 (이 자체로 독립적인 기능을 수행)
2)-메서드로 호출 (자신을 호출한 대상 객체에 관한 동작을 수행)
==> 함수와 메서드는 프로그래밍 언어에서 함수와 메서드는 미리 정의한 동작을 수행하는 코드뭉치로 이 둘의 차이에는 독립성이 있다. 상황별로 사용하면 된다.
*이 둘을 구별하는 방법; 함수 앞에 .의 유무만 판단하면된다. 
존재한다면 메서드로 호출한 것이고 존재하지 않는다면 함수로 호출한 것이다.
(.말고도 대괄호로 판별하는 방법도 있다.)

익명함수는 그대로이지만 이를 변수에 담아 호출한 경우와 obj 객체의 프로퍼티에 할당해서 호출한 경우에 this가 달라지는 것이다.

*메서드 내부에서의 this 
this에서는 호출한 주체에 대한 정보가 담긴다. 어떤 함수를 메서드로서 호출하는 경우 호출 주체는 바로 함수명 앞의 객체
점표기법의 경우 마지막 점 앞에 명시된 객체가 곧 this이 되는 것 
// this의 바인딩에 관해서는 함수를 실행하는 당시의 주변환경은 중요하지 않고 오직 해당함수를 호출하는 구문앞에 점 또는 대광호 표기가 있는지 없는지가 관건

*메서드 내부함수에서의 this를 우회하는 법
ES5까지는 자체적으로 내부함수에 this를 상속할 수 있는 방법이 없지만 이를 우회하는 방법은 있음 => 변수를 활용하는 것

*함수내부에서의 this 
어떤 함수를 함수로서 호출할 경우에는 this가 지정되지않는다. 
this에는 호출한 함수의 정보가 담기지만 함수로서 호출하는 것은 호출주체를 명시하지 않고 개발자가 코드에 직접 관여해서 실행한 것이기 때문에 호출주체의 정보를 알 수 없다.

*this를 바인딩하지 않는 함수
화살표함수: 실행컨텍스트를 생성할 때 바인딩 과정이 빠지게 되어, 상위 스토프의 this를 그대로 활용할 수 있음. (ES6에서는 함수 내부에 this가 전역객체를 바라보는 문제를 보완하고자 this를 바인딩하지 않는 함수를 도입)
/이 외에도 call, apply 등의 메서드를 활용해 함수를 호출할 때 명시적으로 this를 지정하는 방법도 있다.

*콜백함수의 호출시 그 함수 내부에서의 this
콜백함수: 함수A의 제어권을 다른 함수 또는 메서드 B에게 넘겨주는 경우 함수A를 콜백함수라고 한다. 이때 함수A는 함수B의 내부 로직에 따라 실행되며, this 역시 함수B내부로직에서 정한 규칙에 따라 값이 결정된다.
콜백함수도 함수이기 때문에 기본적으로 전역객체를 참조하게 되지만 별도로 제어권을 받은 함수에서는 그 대상이 지정되어 있다면 지정된 대상을 참조하게 된다.

*생성자함수
: 어떤 공통된 성질을 지니는 객체들을 생성하는데 사용하는 함수
(객체지향 언어에서는)생성자: 클래스, 클래스를 통해 만든 객체: 인스턴스
프로그래밍적 생성자는 구체적인 인스턴스를 만들기 위한 일종의 틀로 이는 해당 클래스의 공통 속성들이 미리 준비되어 있고, 이에 구체적인 인스턴스의 개성을 더해 개별 인스턴스를 생성할 수 있다.

*자바스크립트에서 함수에 생성자로서의 역할은 new명령어와함께 함수를 호출하면 해당 함수가 생성자로서 동작하게 된다. 
그리고 어떤 함수가 생성자함수로서 호출된 경우엔 내부에서 this는 곧 새로 만들 구체적인 인스턴스 자신이 된다.