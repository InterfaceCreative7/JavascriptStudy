# 1. 데이터 타입

## 1-1) 데이터 타입의 종류
>
- A) 기본형

    i)      숫자(number)

    ii)     문자열(string)

    iii)    불리언(boolean)

    iv)     null

    v)      undefined

    vi)     심볼(symbol)

- B) 참조형

    i)      객체(object)

    ii)     배열(Array)

    iii)    함수(Function)

    iv)     날짜(Date)

    v)      정규표현식(RegExp)
>
- 기본형은 전부 소문자로 시작하는데, 참조형은 객체를 제외하고 대문자로 시작한다. 이유가 있을까?

## 1-2) 데이터 타입에 대한 배경 지식
>
널널하게 모든 변수는 8byte를 차지한다. => 따라서 형변환을 굳이 해줄 필요가 없다.

>
### 식별자와 변수

> 변수 vs 식별자

변수 = 변할 수 있는 수 => 변할 수 있는 데이터.

식별자 = 어떤 데이터를 식별하는데 쓰는 이름. 즉 변수명.

```js
var a = 100;
//a = 식별자
///var = 변수? 100 = 변수?
```

## 1-3) 변수 선언과 데이터 할당

> 변수 선언

변수 선언을 하면...

컴퓨터의 어떤 공간을 할당받는다. 그리고 그 공간에 이름과 값을 저장한다.

값은 포인터의 형식이다. 그 포인터는 할당된 데이터의 값을 저장하는 또 다른 저장 공간을 가리킨다.  그 과정은 다음과 같다.

1. 변수 영역에서 빈 공간을 확보한다 (ex., @1003).
2. 확보한 공간의 식별자를 a로 지정한다.
3. 데이터 영역의 빈 공간에 정수 100을 저장한다(ex. @5004).
4. 변수 영역에서 a라는 식별자를 검색한다.
5. 앞서 저장한 문자열의 주소를 @1003에 대입한다.

다음과 같은 과정을 거치는 이유는

1. 데이터 변환을 자유롭게 할 수 있음. => 가변적 데이터를 변환할 때에는 저장 공간 또한 조절해줄 필요가 있다. 이 경우, 데이터가 저장된 공간 직접 변형하는 것 보다는, 수정된 값을 또 다른 데이터 공간에 할당한 후 그 주소를 변수에 전달하는 것이 효율적이다.
2. 메모리를 효율적으로 사용. => 같은 값을 다른 변수에 할당해줄 때, 값을 저장할 8바이트짜리 공간을 계속 쓰지 않고 변수를 저장한 주소값을 계속 쓰면 되기 때문이다.

- 4번을 실행하는데 걸리는 시간이 엄청 길지 않을까? 못해도 O(logn)의 시간이 걸릴텐데...

## 1-4) 기본형 데이터와 참조형 데이터

### 불변값

> 불변값 vs 상수 => 변수 영역 메모리를 기준으로 구분한다.

```js
//ex
var a = 'abc'
a = a + 'def'

var b = 5;
var c = 5;
b = 7;
```

의 경우를 보자. 모든 값들, 그러니까 'abc', 'abcdef', 5, 7은 모두 다른 데이터 공간에 있다. c같은 경우는 이미 존재하는 숫자형 데이터 5를 재활용한다.

즉, 불변값의 의미는 데이터 공간의 값이 수정될 수 없는, 불변한다는 의미이다. 그리고 모든 기본형 데이터는 불변값이다.

- 가비지 컬렉팅 : 불변값을 변하게 해주는 유일한 방법? 할당되었지만 쓰이지 않는 데이터를 비워주는 기능인 것 같다. 참고 블로그: 'https://yceffort.kr/2020/12/javascript-garbage-collection'

### 가변값

참조형 데이터가 "대체로" 가변값.

```js
var obj = {
    a: 1,
    b: 'aaa'
}
```

의 경우를 보자. 이 경우

1. 변수 공간의 빈 공간(ex. @1002)를 확보하고, 그 주소의 이름을 obj로 지정

2. 임의의 데이터 저장 공간(ex. @5001)에 데이터를 저장. 그런데 여러개의 프로퍼티로 이루어진 데이터 그룹이므로, 각 내부 프로퍼티를 위한 별도의 변수 영역을 마련하고(ex. @7103 ~ ?), 그 영역의 주소를 @5001에 저장해줌.(필요한 시점에 동적으로 할당해 줌.)

3. @7103 및 @7104에 각각 a, b라는 프로퍼티 이름을 지정

4. 데이터 영역(ex. @5002, @5003)에서 해당하는 데이터를 재활용하거나 새로 만들어서 @7103, @7104에 저장해줌

이때 변수 공간에 저장된 데이터 저장 공간(@5001)의 변수 영역은 얼마든지 바뀔 수 있다. 이러한 특징 때문에 가변값이라고 부른다.

예를 들어, obj의 a에 2라는 값을 저장한다고 해보자. 데이터 공간의 2 (새로 할당한 @5004)을 @7103에 저장한다. 이 경우에 obj1이 바라보고 있는 주소는 여전히 @5001이다.

### 중첩된 가변값

객체 안에 배열이 있는 경우를 생각해 보자. 그러니까 위의 예시에서 b = [1,2,3]이라고 해보자.

그렇다면 데이터 영역에 값('aaa')이 아닌, 배열을 위한 또 다른 변수 영역(ex. @8103 ~ ?)이 마련되고, 그 변수 영역 안에 이름이 각각 0, 1, 2고, 데이터 영역의 1, 2, 3의 값을 가지는 저장 공간을 가리키는 데이터가 생성된다.

### 참조 카운트

>정의: 자신을 참조하는 변수의 개수

이것이 0이 된다면 가비지 컬렉터의 수거 대상이 됨. 즉, 위의 예시에서 다시 obj.b = 'aaa'를 해준다면, @8103 ~ ? 의 참조 카운트는 0이 된다. 따라서 언젠가 값이 사라지게 된다. 그렇다면 그 안의 데이터들인 1, 2, 3또한 참조 카운트가 0이 되어 사라진다.

### 데이터 복사
